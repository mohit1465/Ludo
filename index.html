<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>15x15 Grid with Colored Corners</title>
    <style>
        body {
            margin: 0;
            min-height: 100vh;
            display: flex;
            justify-content: center;
            align-items: center;
            background-color: #f0f0f0;
        }

        .game-container {
            position: relative;
            transform: scale(.8);
        }

        .grid-container {
            display: grid;
            grid-template-columns: repeat(15, 40px);
            grid-template-rows: repeat(15, 40px);
            gap: 1px;
            background-color: #e1e1e1;
            padding: 20px;
            border-radius: 20px;
            width: fit-content;
            margin: auto;
            position: relative;
        }

        .grid-item {
            background-color: white;
            border: 1px solid #00000044;
            width: 100%;
            height: 100%;
            display: flex;
            justify-content: center;
            align-items: center;
            font-size: 12px;
            color: #333;
            position: relative;  /* For absolute positioning of pawns */
        }

        .red-corner { background-color: #ff4444; border: none; }
        .green-corner { background-color: #44ff44; border: none; }
        .blue-corner { background-color: #4444ff; border: none; }
        .yellow-corner { background-color: #ffff44; border: none; }

        .star {
            display: flex;
            justify-content: center;
            align-items: center;
            font-size: 30px !important;
            z-index: 1;  /* Stars behind pawns */
        }

        .star::after {
            content: "â˜…";
            color: #333;
            position: absolute;
        }

        .pawn {
            width: 25px;
            height: 25px;
            border-radius: 50%;
            border: 2px solid rgba(0, 0, 0, 0.3);
            position: absolute;  /* Allow stacking */
            cursor: pointer;
            transition: transform 0.2s ease;
            z-index: 2;  /* Pawns above stars */
            transition: all 0.2s ease;
        }

        .pawn::after {
            content: "";
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            width: 12px;
            height: 12px;
            border-radius: 50%;
            background: rgba(255, 255, 255, 0.7);
        }

        .pawn:hover {
            transform: scale(1.1);
        }

        .red-pawn { background: linear-gradient(135deg, #ff4444, #cc0000); }
        .green-pawn { background: linear-gradient(135deg, #44ff44, #00cc00); }
        .blue-pawn { background: linear-gradient(135deg, #4444ff, #0000cc); }
        .yellow-pawn { background: linear-gradient(135deg, #ffff44, #cccc00); }

        .dice-container {
            position: absolute;
            width: 60px;
            height: 60px;
            cursor: pointer;
            perspective: 1200px;
            background: white;
            border-radius: 12px;
            box-shadow: 0 4px 8px rgba(0,0,0,0.2);
            transition: opacity 0.3s ease;
        }

        .dice {
            width: 100%;
            height: 100%;
            position: relative;
            transform-style: preserve-3d;
            transition: transform 0.2s ease;
        }

        .dice-face {
            position: absolute;
            width: 100%;
            height: 100%;
            display: flex;
            justify-content: center;
            align-items: center;
            background: white;
            border: 2px solid rgba(0, 0, 0, 0.2);  /* Softer border */
            transition: all 0.3s ease;  /* Smoother transitions */
            font-size: 0; /* Hide numbers, we'll use dots */
            backface-visibility: hidden;
        }

        /* Custom faces for red dice */
        #red-dice .dice-face {
            background: linear-gradient(135deg, #ff4444, #cc0000);
            border-radius: 8px;
        }

        #green-dice .dice-face {
            background: linear-gradient(135deg, #44ff44, #00cc00);
            border-radius: 8px;
        }

        #blue-dice .dice-face {
            background: linear-gradient(135deg, #4444ff, #0000cc);
            border-radius: 8px;
        }

        #yellow-dice .dice-face {
            background: linear-gradient(135deg, #ffff44, #cccc00);
            border-radius: 8px;
        }

        /* White dots for all dice */
        #red-dice .dot,
        #green-dice .dot,
        #blue-dice .dot,
        #yellow-dice .dot {
            background: white;
            box-shadow: inset 0 0 2px rgba(255,255,255,0.5);
        }

        /* Define all 6 faces of the dice */
        .dice-face:nth-child(1) { transform: translateZ(30px); }
        .dice-face:nth-child(2) { transform: rotateX(180deg) translateZ(30px); }
        .dice-face:nth-child(3) { transform: rotateY(90deg) translateZ(30px); }
        .dice-face:nth-child(4) { transform: rotateY(-90deg) translateZ(30px); }
        .dice-face:nth-child(5) { transform: rotateX(90deg) translateZ(30px); }
        .dice-face:nth-child(6) { transform: rotateX(-90deg) translateZ(30px); }

        /* Dot styles */
        .dot {
            position: absolute;
            width: 8px;
            height: 8px;
            background: #333;
            border-radius: 50%;
            box-shadow: inset 0 0 2px rgba(0,0,0,0.5);
        }

        .dice-dot {
            width: 8px;
            height: 8px;
            background: #333;
            border-radius: 50%;
            position: absolute;
        }

        /* Updated dice positions */
        #red-dice { 
            top: -80px; 
            left: 5%; 
            background: linear-gradient(135deg, #ff4444, #cc0000);
        }
        #green-dice { 
            top: -80px; 
            right: 5%; 
            background: linear-gradient(135deg, #44ff44, #00cc00);
        }
        #blue-dice { 
            bottom: -80px; 
            left: 5%; 
            background: linear-gradient(135deg, #4444ff, #0000cc);
        }
        #yellow-dice { 
            bottom: -80px; 
            right: 5%; 
            background: linear-gradient(135deg, #ffff44, #cccc00);
        }

        /* Make the board responsive */
        @media (max-width: 800px) {
            .game-container {
                transform: scale(0.8);
            }
        }

        @media (max-width: 600px) {
            .game-container {
                transform: scale(0.6);
            }
        }

        @media (max-width: 400px) {
            .game-container {
                transform: scale(0.5);
            }
        }

        /* Stacked pawn positions */
        .pawn.stacked-1 { transform: translate(-8px, -8px); z-index: 10; }
        .pawn.stacked-2 { transform: translate(8px, -8px); z-index: 11; }
        .pawn.stacked-3 { transform: translate(-8px, 8px); z-index: 12; }
        .pawn.stacked-4 { transform: translate(8px, 8px); z-index: 13; }

        /* Add these styles to your existing CSS */
        .pawn.active-player {
            z-index: 100 !important; /* Force highest z-index for selectable pawns */
            box-shadow: 0 0 10px 3px rgba(255, 252, 236, 0.597);
            animation: pulse 1s infinite;
            pointer-events: auto;
        }

        .pawn:not(.active-player) {
            pointer-events: none;
        }

        @keyframes pulse {
            0% { transform: scale(1); }
            50% { transform: scale(1.1); }
            100% { transform: scale(1); }
        }

        .player-setup-modal {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background-color: rgba(0, 0, 0, 0.8);
            display: flex;
            justify-content: center;
            align-items: center;
            z-index: 1000;
        }

        .modal-content {
            background-color: white;
            padding: 2rem;
            border-radius: 15px;
            box-shadow: 0 4px 6px rgba(0, 0, 0, 0.1);
            max-width: 500px;
            width: 90%;
        }

        .setup-options {
            display: flex;
            flex-direction: column;
            gap: 2rem;
        }

        h2, h3 {
            text-align: center;
            color: #333;
            margin: 0 0 1rem 0;
        }

        .button-group {
            display: flex;
            gap: 1rem;
            justify-content: center;
            flex-wrap: wrap;
        }

        .player-count-btn {
            padding: 0.8rem 1.5rem;
            border: none;
            border-radius: 5px;
            background-color: #e1e1e1;
            cursor: pointer;
            transition: all 0.3s ease;
            font-size: 1rem;
        }

        .player-count-btn:hover {
            background-color: #d1d1d1;
        }

        .player-count-btn.selected {
            background-color: #4CAF50;
            color: white;
        }

        .player-settings {
            display: flex;
            flex-direction: column;
            gap: 1rem;
        }

        .player-config {
            display: flex;
            align-items: center;
            gap: 1rem;
            padding: 1rem;
            background-color: #f5f5f5;
            border-radius: 8px;
        }

        .player-color {
            width: 30px;
            height: 30px;
            border-radius: 50%;
        }

        .player-color.red { background: linear-gradient(135deg, #ff4444, #cc0000); }
        .player-color.green { background: linear-gradient(135deg, #44ff44, #00cc00); }
        .player-color.blue { background: linear-gradient(135deg, #4444ff, #0000cc); }
        .player-color.yellow { background: linear-gradient(135deg, #ffff44, #cccc00); }

        .player-type-select {
            padding: 0.5rem;
            border-radius: 5px;
            border: 1px solid #ccc;
            flex-grow: 1;
            font-size: 1rem;
        }

        .start-game-btn {
            padding: 1rem 2rem;
            background-color: #4CAF50;
            color: white;
            border: none;
            border-radius: 5px;
            cursor: pointer;
            font-size: 1.1rem;
            transition: all 0.3s ease;
        }

        .start-game-btn:hover {
            background-color: #45a049;
        }

        .start-game-btn:disabled {
            background-color: #cccccc;
            cursor: not-allowed;
        }

        @media (max-width: 480px) {
            .modal-content {
                padding: 1rem;
            }
            
            .player-config {
                flex-direction: column;
                text-align: center;
                padding: 0.5rem;
            }
            
            .player-type-select {
                width: 100%;
            }
        }
    </style>
</head>
<body>
    <div class="player-setup-modal" id="playerSetupModal">
        <div class="modal-content">
            <h2>Ludo Game Setup</h2>
            <div class="setup-options">
                <div class="player-count-section">
                    <h3>Select Number of Players</h3>
                    <div class="button-group">
                        <button class="player-count-btn" data-players="2">2 Players</button>
                        <button class="player-count-btn" data-players="3">3 Players</button>
                        <button class="player-count-btn" data-players="4">4 Players</button>
                    </div>
                </div>
                
                <div class="player-settings" id="playerSettings"></div>
                
                <button id="startGameBtn" class="start-game-btn" disabled>Start Game</button>
            </div>
        </div>
    </div>
    <div class="game-container">
        <div class="grid-container">
            <div id="red-dice" class="dice-container">
                <div class="dice">
                    <!-- Face 1: translateZ(30px) - One dot -->
                    <div class="dice-face">
                        <span class="dot" style="margin: auto"></span>
                    </div>
                    <!-- Face 2: rotateX(180deg) - Two dots -->
                    <div class="dice-face">
                        <span class="dot" style="top: 10px; left: 10px"></span>
                        <span class="dot" style="bottom: 10px; right: 10px"></span>
                    </div>
                    <!-- Face 3: rotateY(-90deg) - Three dots -->
                    <div class="dice-face">
                        <span class="dot" style="top: 10px; left: 10px"></span>
                        <span class="dot" style="margin: auto"></span>
                        <span class="dot" style="bottom: 10px; right: 10px"></span>
                    </div>
                    <!-- Face 4: rotateY(90deg) - Four dots -->
                    <div class="dice-face">
                        <span class="dot" style="top: 10px; left: 10px"></span>
                        <span class="dot" style="top: 10px; right: 10px"></span>
                        <span class="dot" style="bottom: 10px; left: 10px"></span>
                        <span class="dot" style="bottom: 10px; right: 10px"></span>
                    </div>
                    <!-- Face 5: rotateX(-90deg) - Five dots -->
                    <div class="dice-face">
                        <span class="dot" style="top: 10px; left: 10px"></span>
                        <span class="dot" style="top: 10px; right: 10px"></span>
                        <span class="dot" style="margin: auto"></span>
                        <span class="dot" style="bottom: 10px; left: 10px"></span>
                        <span class="dot" style="bottom: 10px; right: 10px"></span>
                    </div>
                    <!-- Face 6: rotateX(90deg) - Six dots -->
                    <div class="dice-face">
                        <span class="dot" style="top: 10px; left: 10px"></span>
                        <span class="dot" style="top: 10px; right: 10px"></span>
                        <span class="dot" style="center: 10px; left: 10px"></span>
                        <span class="dot" style="center: 10px; right: 10px"></span>
                        <span class="dot" style="bottom: 10px; left: 10px"></span>
                        <span class="dot" style="bottom: 10px; right: 10px"></span>
                    </div>
                </div>
            </div>
            <div id="green-dice" class="dice-container">
                <div class="dice">
                    <!-- Face 1: translateZ(30px) - One dot -->
                    <div class="dice-face">
                        <span class="dot" style="margin: auto"></span>
                    </div>
                    <!-- Face 2: rotateX(180deg) - Two dots -->
                    <div class="dice-face">
                        <span class="dot" style="top: 10px; left: 10px"></span>
                        <span class="dot" style="bottom: 10px; right: 10px"></span>
                    </div>
                    <!-- Face 3: rotateY(-90deg) - Three dots -->
                    <div class="dice-face">
                        <span class="dot" style="top: 10px; left: 10px"></span>
                        <span class="dot" style="margin: auto"></span>
                        <span class="dot" style="bottom: 10px; right: 10px"></span>
                    </div>
                    <!-- Face 4: rotateY(90deg) - Four dots -->
                    <div class="dice-face">
                        <span class="dot" style="top: 10px; left: 10px"></span>
                        <span class="dot" style="top: 10px; right: 10px"></span>
                        <span class="dot" style="bottom: 10px; left: 10px"></span>
                        <span class="dot" style="bottom: 10px; right: 10px"></span>
                    </div>
                    <!-- Face 5: rotateX(-90deg) - Five dots -->
                    <div class="dice-face">
                        <span class="dot" style="top: 10px; left: 10px"></span>
                        <span class="dot" style="top: 10px; right: 10px"></span>
                        <span class="dot" style="margin: auto"></span>
                        <span class="dot" style="bottom: 10px; left: 10px"></span>
                        <span class="dot" style="bottom: 10px; right: 10px"></span>
                    </div>
                    <!-- Face 6: rotateX(90deg) - Six dots -->
                    <div class="dice-face">
                        <span class="dot" style="top: 10px; left: 10px"></span>
                        <span class="dot" style="top: 10px; right: 10px"></span>
                        <span class="dot" style="center: 10px; left: 10px"></span>
                        <span class="dot" style="center: 10px; right: 10px"></span>
                        <span class="dot" style="bottom: 10px; left: 10px"></span>
                        <span class="dot" style="bottom: 10px; right: 10px"></span>
                    </div>
                </div>
            </div>
            <div id="blue-dice" class="dice-container">
                <div class="dice">
                    <!-- Face 1: translateZ(30px) - One dot -->
                    <div class="dice-face">
                        <span class="dot" style="margin: auto"></span>
                    </div>
                    <!-- Face 2: rotateX(180deg) - Two dots -->
                    <div class="dice-face">
                        <span class="dot" style="top: 10px; left: 10px"></span>
                        <span class="dot" style="bottom: 10px; right: 10px"></span>
                    </div>
                    <!-- Face 3: rotateY(-90deg) - Three dots -->
                    <div class="dice-face">
                        <span class="dot" style="top: 10px; left: 10px"></span>
                        <span class="dot" style="margin: auto"></span>
                        <span class="dot" style="bottom: 10px; right: 10px"></span>
                    </div>
                    <!-- Face 4: rotateY(90deg) - Four dots -->
                    <div class="dice-face">
                        <span class="dot" style="top: 10px; left: 10px"></span>
                        <span class="dot" style="top: 10px; right: 10px"></span>
                        <span class="dot" style="bottom: 10px; left: 10px"></span>
                        <span class="dot" style="bottom: 10px; right: 10px"></span>
                    </div>
                    <!-- Face 5: rotateX(-90deg) - Five dots -->
                    <div class="dice-face">
                        <span class="dot" style="top: 10px; left: 10px"></span>
                        <span class="dot" style="top: 10px; right: 10px"></span>
                        <span class="dot" style="margin: auto"></span>
                        <span class="dot" style="bottom: 10px; left: 10px"></span>
                        <span class="dot" style="bottom: 10px; right: 10px"></span>
                    </div>
                    <!-- Face 6: rotateX(90deg) - Six dots -->
                    <div class="dice-face">
                        <span class="dot" style="top: 10px; left: 10px"></span>
                        <span class="dot" style="top: 10px; right: 10px"></span>
                        <span class="dot" style="center: 10px; left: 10px"></span>
                        <span class="dot" style="center: 10px; right: 10px"></span>
                        <span class="dot" style="bottom: 10px; left: 10px"></span>
                        <span class="dot" style="bottom: 10px; right: 10px"></span>
                    </div>
                </div>
            </div>
            <div id="yellow-dice" class="dice-container">
                <div class="dice">
                    <!-- Face 1: translateZ(30px) - One dot -->
                    <div class="dice-face">
                        <span class="dot" style="margin: auto"></span>
                    </div>
                    <!-- Face 2: rotateX(180deg) - Two dots -->
                    <div class="dice-face">
                        <span class="dot" style="top: 10px; left: 10px"></span>
                        <span class="dot" style="bottom: 10px; right: 10px"></span>
                    </div>
                    <!-- Face 3: rotateY(-90deg) - Three dots -->
                    <div class="dice-face">
                        <span class="dot" style="top: 10px; left: 10px"></span>
                        <span class="dot" style="margin: auto"></span>
                        <span class="dot" style="bottom: 10px; right: 10px"></span>
                    </div>
                    <!-- Face 4: rotateY(90deg) - Four dots -->
                    <div class="dice-face">
                        <span class="dot" style="top: 10px; left: 10px"></span>
                        <span class="dot" style="top: 10px; right: 10px"></span>
                        <span class="dot" style="bottom: 10px; left: 10px"></span>
                        <span class="dot" style="bottom: 10px; right: 10px"></span>
                    </div>
                    <!-- Face 5: rotateX(-90deg) - Five dots -->
                    <div class="dice-face">
                        <span class="dot" style="top: 10px; left: 10px"></span>
                        <span class="dot" style="top: 10px; right: 10px"></span>
                        <span class="dot" style="margin: auto"></span>
                        <span class="dot" style="bottom: 10px; left: 10px"></span>
                        <span class="dot" style="bottom: 10px; right: 10px"></span>
                    </div>
                    <!-- Face 6: rotateX(90deg) - Six dots -->
                    <div class="dice-face">
                        <span class="dot" style="top: 10px; left: 10px"></span>
                        <span class="dot" style="top: 10px; right: 10px"></span>
                        <span class="dot" style="center: 10px; left: 10px"></span>
                        <span class="dot" style="center: 10px; right: 10px"></span>
                        <span class="dot" style="bottom: 10px; left: 10px"></span>
                        <span class="dot" style="bottom: 10px; right: 10px"></span>
                    </div>
                </div>
            </div>
            <script>
                const container = document.querySelector('.grid-container');
                let cellNumber = 1;
                
                // Define path cells for each color
                const redPath = [92, 107, 108, 109, 110, 111];
                const yellowPath = [115, 116, 117, 118, 119, 134];
                const bluePath = [202, 203, 188, 173, 158, 143];
                const greenPath = [23, 24, 38, 53, 68, 83];

                // Define star positions
                const starPositions = [37, 103, 123, 189];
                
                // Define pawn positions
                const redPawns = [17, 20, 62, 65];
                const greenPawns = [17+9, 20+9, 62+9, 65+9];
                const bluePawns = [17+135, 20+135, 62+135, 65+135];
                const yellowPawns = [17+144, 20+144, 62+144, 65+144];

                // Starting positions for each color
                const startPositions = {
                    red: 92,
                    green: 24,
                    yellow: 134,
                    blue: 202
                };

                // Home positions for each color
                const homePositions = {
                    red: [17, 20, 62, 65],
                    green: [26, 29, 71, 74],
                    blue: [152, 155, 197, 200],
                    yellow: [161, 164, 206, 209]
                };

                // Define complete paths for each color
                const completePaths = {
                    red: [92, 93, 94, 95, 96, 82, 67, 52, 37, 22, 7, 8, 9, 24, 39, 54, 69, 84, 100, 101, 102, 103, 104, 105, 120, 135, 134, 133, 132, 131, 130, 144, 159, 174, 189, 204, 219, 218, 217, 202, 187, 172, 157, 142, 126, 125, 124, 123, 122, 121, 106, 107, 108, 109, 110, 111, 112],
                    green: [24, 39, 54, 69, 84, 100, 101, 102, 103, 104, 105, 120, 135, 134, 133, 132, 131, 130, 144, 159, 174, 189, 204, 219, 218, 217, 202, 187, 172, 157, 142, 126, 125, 124, 123, 122, 121, 106, 91, 92, 93, 94, 95, 96, 82, 67, 52, 37, 22, 7, 8, 23, 38, 53, 68, 83, 98],
                    yellow: [134, 133, 132, 131, 130, 144, 159, 174, 189, 204, 219, 218, 217, 202, 187, 172, 157, 142, 126, 125, 124, 123, 122, 121, 106, 91, 92, 93, 94, 95, 96, 82, 67, 52, 37, 22, 7, 8, 9, 24, 39, 54, 69, 84, 100, 101, 102, 103, 104, 105, 120, 119, 118, 117, 116, 115, 114],
                    blue: [202, 187, 172, 157, 142, 126, 125, 124, 123, 122, 121, 106, 91, 92, 93, 94, 95, 96, 82, 67, 52, 37, 22, 7, 8, 9, 24, 39, 54, 69, 84, 100, 101, 102, 103, 104, 105, 120, 135, 134, 133, 132, 131, 130, 144, 159, 174, 189, 204, 219, 218, 203, 188, 173, 158, 143, 128]
                };

                // First, add this constant to track safe positions
                const safePositions = [
                    ...starPositions,           // Star positions
                    startPositions.red,         // Starting points
                    startPositions.green,
                    startPositions.yellow,
                    startPositions.blue
                ];

                // Initialize game state
                const gameState = {
                    currentPlayer: 'red', // Start with red player
                    consecutiveSixes: 0,
                    canRoll: true,
                    canSelectPawn: false,
                    lastRoll: 0
                };

                // Move these declarations to the top of your script, right after the path definitions
                const gameConfig = {
                    players: {},
                    totalPlayers: 0
                };

                // Move these declarations as well
                const playerSetupModal = document.getElementById('playerSetupModal');
                const playerCountBtns = document.querySelectorAll('.player-count-btn');
                const playerSettings = document.getElementById('playerSettings');
                const startGameBtn = document.getElementById('startGameBtn');
                const colorNames = ['red', 'green', 'blue', 'yellow'];
                let selectedPlayerCount = 0;

                // Player sequence (clockwise)
                let playerSequence = ['red', 'green', 'yellow', 'blue'];

                // Function to handle pawn selection from home
                function handlePawnSelection(event) {
                    const pawn = event.target;
                    const cell = pawn.parentElement;
                    
                    if (!gameState.canSelectPawn) return;
                    
                    const pawnColor = Array.from(pawn.classList)
                        .find(cls => cls.includes('-pawn'))
                        .replace('-pawn', '');
                        
                    if (pawnColor !== gameState.currentPlayer) return;
                    
                    const currentPosition = parseInt(cell.dataset.cellNumber);
                    
                    // Handle pawn in home position
                    if (homePositions[pawnColor].includes(currentPosition)) {
                        if (gameState.lastRoll === 6) {
                            movePawn(pawn, startPositions[pawnColor]);
                            gameState.canSelectPawn = false;
                            gameState.canRoll = true;
                        }
                    } 
                    // Handle pawn on the board
                    else {
                        const currentPathIndex = completePaths[pawnColor].indexOf(currentPosition);
                        if (currentPathIndex !== -1) {
                            const newPathIndex = currentPathIndex + gameState.lastRoll;
                            if (newPathIndex < completePaths[pawnColor].length) {
                                const newPosition = completePaths[pawnColor][newPathIndex];
                                movePawn(pawn, newPosition);
                                gameState.canSelectPawn = false;
                                gameState.canRoll = true;
                            }
                        }
                    }

                    if (!gameState.canSelectPawn) {
                        if (gameState.lastRoll === 6) {
                            gameState.canRoll = true;
                        } else {
                            gameState.currentPlayer = getNextPlayer();
                            gameState.canRoll = true;
                        }
                        updateDiceVisibility();
                    }
                }

                // Update the movePawn function to handle stacking on safe positions:
                function movePawn(pawn, newPosition) {
                    const oldCell = pawn.parentElement;
                    const newCell = document.querySelector(`.grid-item[data-cell-number="${newPosition}"]`);
                    const pawnColor = pawn.classList[1].split('-')[0]; // Store original color
                    
                    if (newCell) {
                        const existingPawns = newCell.querySelectorAll('.pawn');
                        const isSafePosition = safePositions.includes(newPosition);
                        
                        if (existingPawns.length > 0) {
                            const firstPawnColor = existingPawns[0].classList[1].split('-')[0];
                            
                            if (firstPawnColor !== pawnColor) {
                                if (isSafePosition) {
                                    // Safe position stacking
                                    oldCell.removeChild(pawn);
                                    newCell.appendChild(pawn);
                                    // Ensure pawn maintains its original color
                                    pawn.className = `pawn ${pawnColor}-pawn`;
                                    
                                    // Update z-index for stacking
                                    const allPawnsInCell = newCell.querySelectorAll('.pawn');
                                    allPawnsInCell.forEach((p, index) => {
                                        const color = p.classList[1].split('-')[0];
                                        p.className = `pawn ${color}-pawn`; // Maintain original colors
                                        p.style.zIndex = (index + 2).toString();
                                        // Add stacking positions
                                        if (index === 0) p.style.transform = 'translate(-8px, -8px)';
                                        if (index === 1) p.style.transform = 'translate(8px, -8px)';
                                        if (index === 2) p.style.transform = 'translate(-8px, 8px)';
                                        if (index === 3) p.style.transform = 'translate(8px, 8px)';
                                    });
                                } else {
                                    // Capture logic
                                    existingPawns.forEach(existingPawn => {
                                        const existingPawnColor = existingPawn.classList[1].split('-')[0];
                                        const homePosition = findAvailableHomePosition(existingPawnColor);
                                        const homeCell = document.querySelector(`.grid-item[data-cell-number="${homePosition}"]`);
                                        newCell.removeChild(existingPawn);
                                        homeCell.appendChild(existingPawn);
                                        // Ensure captured pawn maintains its original color
                                        existingPawn.className = `pawn ${existingPawnColor}-pawn`;
                                        existingPawn.style.transform = '';
                                        existingPawn.style.zIndex = '2';
                                    });
                                    oldCell.removeChild(pawn);
                                    newCell.appendChild(pawn);
                                    // Ensure moving pawn maintains its color
                                    pawn.className = `pawn ${pawnColor}-pawn`;
                                    pawn.style.transform = '';
                                    pawn.style.zIndex = '2';
                                }
                            } else {
                                // Stack same color pawns
                                oldCell.removeChild(pawn);
                                newCell.appendChild(pawn);
                                const allPawnsInCell = newCell.querySelectorAll('.pawn');
                                allPawnsInCell.forEach((p, index) => {
                                    p.className = `pawn ${pawnColor}-pawn stacked-${index + 1}`;
                                });
                            }
                        } else {
                            // No existing pawns
                            oldCell.removeChild(pawn);
                            newCell.appendChild(pawn);
                            pawn.className = `pawn ${pawnColor}-pawn`;
                            pawn.style.transform = '';
                            pawn.style.zIndex = '2';
                        }
                    }
                }

                // Add this new function to find available home position
                function findAvailableHomePosition(color) {
                    const positions = homePositions[color];
                    
                    // Find first empty home position
                    for (const position of positions) {
                        const cell = document.querySelector(`.grid-item[data-cell-number="${position}"]`);
                        if (!cell.querySelector('.pawn')) {
                            return position;
                        }
                    }
                    
                    // If all positions are occupied, return the first one (shouldn't happen in normal gameplay)
                    return positions[0];
                }

                for (let row = 0; row < 15; row++) {
                    for (let col = 0; col < 15; col++) {
                        const cell = document.createElement('div');
                        cell.className = 'grid-item';
                        cell.dataset.cellNumber = cellNumber;
                        
                        // Add stars
                        if (starPositions.includes(cellNumber)) {
                            cell.textContent = ''; // Remove the cell number
                            cell.classList.add('star');
                        }

                        // Add pawns
                        if (redPawns.includes(cellNumber)) {
                            cell.textContent = '';
                            const pawn = document.createElement('div');
                            pawn.className = 'pawn red-pawn';
                            cell.appendChild(pawn);
                        }
                        if (greenPawns.includes(cellNumber)) {
                            cell.textContent = '';
                            const pawn = document.createElement('div');
                            pawn.className = 'pawn green-pawn';
                            cell.appendChild(pawn);
                        }
                        if (bluePawns.includes(cellNumber)) {
                            cell.textContent = '';
                            const pawn = document.createElement('div');
                            pawn.className = 'pawn blue-pawn';
                            cell.appendChild(pawn);
                        }
                        if (yellowPawns.includes(cellNumber)) {
                            cell.textContent = '';
                            const pawn = document.createElement('div');
                            pawn.className = 'pawn yellow-pawn';
                            cell.appendChild(pawn);
                        }

                        // Top-left red corner
                        if (row < 6 && col < 6) {
                            cell.classList.add('red-corner');
                        }
                        // Top-right green corner
                        if (row < 6 && col >= 9) {
                            cell.classList.add('green-corner');
                        }
                        // Bottom-left blue corner
                        if (row >= 9 && col < 6) {
                            cell.classList.add('blue-corner');
                        }
                        // Bottom-right yellow corner
                        if (row >= 9 && col >= 9) {
                            cell.classList.add('yellow-corner');
                        }

                        // Add path colors
                        if (redPath.includes(cellNumber)) {
                            cell.classList.add('red-corner');
                        }
                        if (yellowPath.includes(cellNumber)) {
                            cell.classList.add('yellow-corner');
                        }
                        if (bluePath.includes(cellNumber)) {
                            cell.classList.add('blue-corner');
                        }
                        if (greenPath.includes(cellNumber)) {
                            cell.classList.add('green-corner');
                        }
                        
                        container.appendChild(cell);
                        cellNumber++;
                    }
                }

                // Dice rolling functionality
                function rollDice(diceId) {
                    const playerColor = diceId.split('-')[0];
                    
                    // Check if it's the right player's turn and if they can roll
                    if (playerColor !== gameState.currentPlayer || !gameState.canRoll) {
                        console.log('Roll blocked - wrong player or cannot roll');
                        return;
                    }

                    gameState.canRoll = false;
                    const dice = document.querySelector(`#${diceId} .dice`);
                    const result = Math.floor(Math.random() * 6) + 1;
                    
                    let rotations = 0;
                    const totalRotations = 1;
                    const animationDuration = 80;

                    function animate() {
                        if (rotations < totalRotations * 10) {
                            const xRot = Math.random() * 360;
                            const yRot = Math.random() * 360;
                            const zRot = Math.random() * 360;
                            const ease = 1 - (rotations / (totalRotations * 10));
                            const speed = animationDuration * ease;
                            
                            dice.style.transform = `rotateX(${xRot}deg) rotateY(${yRot}deg) rotateZ(${zRot}deg)`;
                            rotations++;
                            
                            setTimeout(animate, speed);
                        } else {
                            const finalRotations = {
                                1: 'rotateX(0deg) rotateY(0deg)',      // One dot face
                                2: 'rotateX(180deg)',                  // Two dots face
                                3: 'rotateY(-90deg)',                   // Three dots face
                                4: 'rotateY(90deg)',                   // Four dots face
                                5: 'rotateX(-90deg)',                  // Five dots face
                                6: 'rotateX(90deg)',                  // Six dots face
                            };
                            
                            dice.style.transition = 'transform 0.8s cubic-bezier(0.25, 0.1, 0.25, 1)';
                            dice.style.transform = finalRotations[result];
                            
                            // Handle result after animation
                            setTimeout(() => {
                                console.log('Processing dice roll result:', result);
                                gameState.lastRoll = result;
                                const playerPawns = document.querySelectorAll(`.${gameState.currentPlayer}-pawn`);
                                let hasValidMove = false;

                                // Check if any pawn can move
                                playerPawns.forEach(pawn => {
                                    const currentPosition = parseInt(pawn.parentElement.dataset.cellNumber);
                                    console.log('Checking pawn at position:', currentPosition);
                                    
                                    // If pawn is in home and rolled a 6
                                    if (homePositions[gameState.currentPlayer].includes(currentPosition) && result === 6) {
                                        hasValidMove = true;
                                        console.log('Valid move: Can move from home with 6');
                                    }
                                    // If pawn is on board
                                    else if (!homePositions[gameState.currentPlayer].includes(currentPosition)) {
                                        const currentPathIndex = completePaths[gameState.currentPlayer].indexOf(currentPosition);
                                        if (currentPathIndex !== -1 && (currentPathIndex + result) < completePaths[gameState.currentPlayer].length) {
                                            hasValidMove = true;
                                            console.log('Valid move: Can move on board');
                                        }
                                    }
                                });

                                console.log('Has valid move:', hasValidMove);
                                console.log('Roll result:', result);

                                if (result === 6) {
                                    gameState.consecutiveSixes++;
                                    if (gameState.consecutiveSixes === 3) {
                                        console.log('Three consecutive sixes, switching player');
                                        gameState.currentPlayer = getNextPlayer();
                                        gameState.consecutiveSixes = 0;
                                        gameState.canRoll = true;
                                        gameState.canSelectPawn = false;
                                    } else {
                                        console.log('Rolled a 6, allowing pawn selection');
                                        gameState.canSelectPawn = true;
                                        gameState.canRoll = false;
                                    }
                                } else if (hasValidMove) {
                                    console.log('Has valid moves, allowing pawn selection');
                                    gameState.canSelectPawn = true;
                                    gameState.canRoll = false;
                                    gameState.consecutiveSixes = 0;
                                } else {
                                    console.log('No valid moves, switching player');
                                    gameState.currentPlayer = getNextPlayer();
                                    gameState.canRoll = true;
                                    gameState.canSelectPawn = false;
                                    gameState.consecutiveSixes = 0;
                                }
                                
                                console.log('Game state after roll:', {
                                    currentPlayer: gameState.currentPlayer,
                                    canRoll: gameState.canRoll,
                                    canSelectPawn: gameState.canSelectPawn,
                                    lastRoll: gameState.lastRoll
                                });
                                
                                updateDiceVisibility();
                            }, 800);
                        }
                    }

                    dice.style.transition = 'transform 0.2s cubic-bezier(0.4, 0.0, 0.2, 1)';
                    animate();
                }

                // Add click event listeners to dice
                document.querySelectorAll('.dice-container').forEach(dice => {
                    dice.addEventListener('click', () => {
                        rollDice(dice.id);
                    });
                });

                // Function to get next player
                function getNextPlayer() {
                    const currentIndex = playerSequence.indexOf(gameState.currentPlayer);
                    return playerSequence[(currentIndex + 1) % playerSequence.length];
                }

                // Add function to update pawn highlights
                function updatePawnHighlights() {
                    // Remove highlight from all pawns
                    document.querySelectorAll('.pawn').forEach(pawn => {
                        pawn.classList.remove('active-player');
                    });
                    
                    // Add highlight to current player's pawns
                    document.querySelectorAll(`.${gameState.currentPlayer}-pawn`).forEach(pawn => {
                        if (gameState.canSelectPawn) {
                            const position = parseInt(pawn.parentElement.dataset.cellNumber);
                            const isInHome = homePositions[gameState.currentPlayer].includes(position);
                            const currentPathIndex = completePaths[gameState.currentPlayer].indexOf(position);
                            
                            // Highlight only if pawn can move
                            if ((isInHome && gameState.lastRoll === 6) || 
                                (!isInHome && currentPathIndex !== -1 && 
                                 (currentPathIndex + gameState.lastRoll) < completePaths[gameState.currentPlayer].length)) {
                                pawn.classList.add('active-player');
                            }
                        }
                    });
                }

                // Update the updateDiceVisibility function
                function updateDiceVisibility() {
                    // Update dice visibility
                    document.querySelectorAll('.dice-container').forEach(dice => {
                        if (dice.id === `${gameState.currentPlayer}-dice`) {
                            dice.style.opacity = '1';
                            dice.style.cursor = gameState.canRoll ? 'pointer' : 'not-allowed';
                        } else {
                            dice.style.opacity = '0.3';
                            dice.style.cursor = 'not-allowed';
                        }
                    });
                    
                    // Update pawn highlights
                    updatePawnHighlights();

                    // Check for computer turn ONLY if current player is a computer
                    const currentPlayerType = gameConfig.players[gameState.currentPlayer]?.type;
                    console.log('Current player:', gameState.currentPlayer, 'Type:', currentPlayerType);
                    
                    if (currentPlayerType === 'computer' && gameState.canRoll) {
                        setTimeout(async () => {
                            console.log('Triggering computer turn for', gameState.currentPlayer);
                            await checkComputerTurn();
                        }, 1500);
                    } else {
                        console.log('Human player turn or cannot roll');
                    }
                }

                // Add click event listeners to pawns
                document.querySelectorAll('.pawn').forEach(pawn => {
                    pawn.addEventListener('click', handlePawnSelection);
                });

                // Initialize the game
                updateDiceVisibility();

                // Handle player count selection
                playerCountBtns.forEach(btn => {
                    btn.addEventListener('click', () => {
                        playerCountBtns.forEach(b => b.classList.remove('selected'));
                        btn.classList.add('selected');
                        selectedPlayerCount = parseInt(btn.dataset.players);
                        updatePlayerSettings();
                        startGameBtn.disabled = false;
                    });
                });

                function updatePlayerSettings() {
                    playerSettings.innerHTML = '';
                    
                    for (let i = 0; i < selectedPlayerCount; i++) {
                        const playerConfig = document.createElement('div');
                        playerConfig.className = 'player-config';
                        
                        const colorDiv = document.createElement('div');
                        colorDiv.className = `player-color ${colorNames[i]}`;
                        
                        const select = document.createElement('select');
                        select.className = 'player-type-select';
                        select.dataset.color = colorNames[i];
                        
                        select.innerHTML = `
                            <option value="human">Human Player</option>
                            <option value="computer">Computer Player</option>
                        `;
                        
                        playerConfig.appendChild(colorDiv);
                        playerConfig.appendChild(select);
                        playerSettings.appendChild(playerConfig);
                    }
                }

                // Handle game start
                startGameBtn.addEventListener('click', () => {
                    if (!selectedPlayerCount) {
                        alert('Please select the number of players');
                        return;
                    }

                    // Configure game based on selections
                    gameConfig.totalPlayers = selectedPlayerCount;
                    gameConfig.players = {};

                    // Set up active players
                    document.querySelectorAll('.player-type-select').forEach(select => {
                        gameConfig.players[select.dataset.color] = {
                            type: select.value,
                            active: true
                        };
                    });

                    // Disable unused players
                    colorNames.forEach(color => {
                        if (!gameConfig.players[color]) {
                            gameConfig.players[color] = {
                                type: 'inactive',
                                active: false
                            };
                        }
                    });

                    // Update player sequence to only include active players
                    playerSequence = colorNames.filter(color => gameConfig.players[color]?.active);

                    // Initialize game state
                    gameState.currentPlayer = playerSequence[0];
                    
                    // Hide modal
                    playerSetupModal.style.display = 'none';
                    
                    // Initialize AI if needed
                    if (Object.values(gameConfig.players).some(p => p.type === 'computer')) {
                        initializeAI();
                    }
                    
                    // Update UI
                    updateDiceVisibility();
                });

                // Show setup modal when page loads
                document.addEventListener('DOMContentLoaded', () => {
                    playerSetupModal.style.display = 'flex';
                });

                // Add this after the initializeAI declaration
                async function initializeAI() {
                    await checkComputerTurn();
                }

                async function checkComputerTurn() {
                    if (gameState.currentPlayer && 
                        gameConfig.players[gameState.currentPlayer]?.type === 'computer' && 
                        gameState.canRoll) {
                        await sleep(500); // Wait before starting computer turn
                        await computerPlay();
                    }
                }

                // Add sleep helper function
                function sleep(ms) {
                    return new Promise(resolve => setTimeout(resolve, ms));
                }

                // Update computerPlay to be async
                async function computerPlay() {
                    console.log('computerPlay started for', gameState.currentPlayer);
                    const diceId = `${gameState.currentPlayer}-dice`;
                    
                    // Roll dice and wait for animation
                    console.log('Rolling dice:', diceId);
                    rollDice(diceId);
                    await sleep(1500); // Wait for dice roll animation
                    
                    console.log('Dice roll complete:', {
                        currentPlayer: gameState.currentPlayer,
                        canRoll: gameState.canRoll,
                        canSelectPawn: gameState.canSelectPawn,
                        lastRoll: gameState.lastRoll
                    });
                    
                    // Wait until pawn selection is possible
                    let attempts = 0;
                    while (!gameState.canSelectPawn && attempts < 5) {
                        await sleep(300);
                        attempts++;
                    }
                    
                    if (gameState.canSelectPawn) {
                        console.log('Finding best move...');
                        const bestMove = findBestMove();
                        console.log('Best move found:', bestMove);
                        
                        if (bestMove) {
                            console.log('Executing move:', bestMove);
                            const event = new MouseEvent('click', {
                                bubbles: true,
                                cancelable: true,
                                view: window
                            });
                            bestMove.pawn.dispatchEvent(event);
                            
                            // Wait for move animation
                            await sleep(500);
                            
                            // Check if we got a 6 and can roll again
                            if (gameState.lastRoll === 6 && gameState.canRoll) {
                                console.log('Got a 6, playing another turn');
                                await computerPlay();
                            } else {
                                console.log('Turn complete');
                                updateDiceVisibility();
                            }
                        } else {
                            console.log('No valid moves available');
                            gameState.currentPlayer = getNextPlayer();
                            gameState.canRoll = true;
                            updateDiceVisibility();
                        }
                    }
                }

                function findBestMove() {
                    console.log('Starting findBestMove for player:', gameState.currentPlayer);
                    const playerPawns = document.querySelectorAll(`.${gameState.currentPlayer}-pawn`);
                    console.log('Found pawns:', playerPawns.length);
                    
                    let bestMove = null;
                    let bestScore = -1;
                
                    // Evaluate each possible move
                    playerPawns.forEach((pawn, index) => {
                        const currentPosition = parseInt(pawn.parentElement.dataset.cellNumber);
                        console.log(`Evaluating pawn ${index + 1} at position:`, currentPosition);
                        
                        // If pawn is in home
                        if (homePositions[gameState.currentPlayer].includes(currentPosition)) {
                            console.log('Pawn is in home');
                            if (gameState.lastRoll === 6) {
                                const score = evaluateMove(pawn, startPositions[gameState.currentPlayer]);
                                console.log('Home pawn with 6 - Score:', score);
                                if (score > bestScore) {
                                    bestScore = score;
                                    bestMove = {
                                        pawn: pawn,
                                        newPosition: startPositions[gameState.currentPlayer]
                                    };
                                }
                            }
                        } 
                        // If pawn is on board
                        else {
                            console.log('Pawn is on board');
                            const currentPathIndex = completePaths[gameState.currentPlayer].indexOf(currentPosition);
                            if (currentPathIndex !== -1) {
                                const newPathIndex = currentPathIndex + gameState.lastRoll;
                                if (newPathIndex < completePaths[gameState.currentPlayer].length) {
                                    const newPosition = completePaths[gameState.currentPlayer][newPathIndex];
                                    const score = evaluateMove(pawn, newPosition);
                                    console.log(`Possible move to ${newPosition} - Score:`, score);
                                    if (score > bestScore) {
                                        bestScore = score;
                                        bestMove = {
                                            pawn: pawn,
                                            newPosition: newPosition
                                        };
                                    }
                                }
                            }
                        }
                    });
                
                    console.log('Final best move:', bestMove);
                    return bestMove;
                }

                // Also add evaluateMove function that was missing
                function evaluateMove(pawn, newPosition) {
                    let score = 0;
                    const currentPosition = parseInt(pawn.parentElement.dataset.cellNumber);
                    
                    // Prioritize getting out of home
                    if (homePositions[gameState.currentPlayer].includes(currentPosition) && gameState.lastRoll === 6) {
                        score += 100;
                    }
                
                    // Check if can capture opponent
                    const targetCell = document.querySelector(`.grid-item[data-cell-number="${newPosition}"]`);
                    if (targetCell) {
                        const existingPawn = targetCell.querySelector('.pawn');
                        if (existingPawn && !existingPawn.classList.contains(`${gameState.currentPlayer}-pawn`)) {
                            score += 75;
                        }
                    }
                
                    // Prioritize safe spots
                    if (safePositions.includes(newPosition)) {
                        score += 50;
                    }
                
                    // Prefer forward progress
                    const pathIndex = completePaths[gameState.currentPlayer].indexOf(newPosition);
                    if (pathIndex !== -1) {
                        score += pathIndex * 2;
                    }
                
                    return score;
                }
            </script>
        </div>
    </div>
</body>
</html>